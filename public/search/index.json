
{
    
    
    
    
        
        
        
    
    "pages": [{"date":"2024-04-20","image":"","imageAlt":"","link":"http://localhost:1313/posts/id-software-prinicpals-of-good-development/","summary":"Recently I watched a conference talk by the legend: John Romero, of ID software. During this presentation, he introduced a set of core principals the team used during the development of Wolfenstein 3D through to the Quake era to keep their games shippable and bug free at all times. There is alot of wisdom here from one of the all time greats that was in the trenches of the 90\u0026rsquo;s game development scene.","tags":["id","john romero","post","software"],"text":"recently i watched a conference talk by the legend: john romero, of id software. during this presentation, he introduced a set of core principals the team used during the development of wolfenstein 3d through to the quake era to keep their games shippable and bug free at all times. there is alot of wisdom here from one of the all time greats that was in the trenches of the 90\u0026rsquo;s game development scene. back when jut a couple of people and a computer could produce a mega hit that took the world by storm. although those days are long past (to my deepest sorrow), these principals stand as wisdom from our ancesors to be meditated upon and considered deeply in how they can apply to every programmers daily coding life.\nprincipal 1: no prototypes. just make the game. polish as you go. don\u0026#39;t depend on polish happening later. always maintain constantly shippable code. this, as romero says, is how they made so many games at such a quick pace. the game was all in their minds eye and just needed to be built.\nprincipal 2: its incredibly important that your game can always be run by your team. bulletprood your engine by providing defaults upon load failure. this principal was key when they moved their offices accross the country and couldn\u0026rsquo;t waste any development time during this period. this princpal ensures that there is never a situation where there are people waiting around for a fix when something fails. the game could always be loaded even when assets were missing or there was bad, corrupted or inconsistant data.\nprincipal 3: keep your code absolutly simple. keep looking at your functions and figure out how you can simplify further. this one is fairly easy to understand. keeping a simple and readable codebase allows others as well as yourself to understand at a glance what a function is doing without having to dive through the codebase and waste time analysing how it works.\nprincipal 4: great tools help make great games. spend as much time on tools as possible. the perfect example of this principal in practice is romeros tile editor: ted. this tile editor was in service through the development of 33 shipped retail games. it is quite easy to see how the existance of this particular tool sped up the development of future projects. the tooling surrounding a project can be just as important as the project itself.\nprincipal 5: we are our own best testing team and should never allow anoyone else to experience bugs or see the game crash. don\u0026#39;t waste other\u0026#39;s time. test thoroughly before checking in your code. this one may seem obvious but is often overlooked. in modern times where there are qa departments, it is very easy to spit out your code, do a couple of happy path tests and call it done and let the qa person find anything you have overlooked. in professional software development where there a time pressures and promises made to clients of new features, we should try to remember that a buggy feature is often much worse that shipping a week late.\nprincipal 6: as soon as you see a bug, you fix it. do not continue on. if you don\u0026#39;t fix your bugs, your new code will be built on a buggy codebase and ensure an unstable foundation. this is a follow on from principal 5. best efforts should be made to fix any bugs you\u0026rsquo;ve introduced, or log a bug ticket for something you have found in another team\u0026rsquo;s code.\nprinciplal 7: use a development system that is superior to your target. back when id sofware were targeting msdos, they used the nextstep computers to develop doom. the nextstep computers were the most expensive, highest power machines you could buy. this allowed the team to uphold principal 4. they found they could create far better tooling with the beefier computers. in the age where most apps are aimed for the web, this one may seem a little outdated. i suppose it could still be relevant for standalone applications or games. but in an era where good hardware is cheap, this one is not hard to follow.\nprincipal 8: write your code for this game only - not for a future game. you\u0026#39;re going to be writing new code later because you\u0026#39;ll be smarter. this makes sense for a game. a game is a one off product and once shipped, its shipped. it doesnt really apply to saas products as these generally stick around and are modified over and over. in the codebase im working in currently, i\u0026rsquo;ve seen commits from over 10 years ago that are still in service today. adapting this principal a little and we come to one of my main philosophies of software development: dont over generalise your classes and methods. dont try to be the master key to everyones problems. write code for the job that needs to be done and not for some future that may not happen. this, to me, means that we shouldnt try to make out functions work for undefined behaviour, we should just do the job we are trying to do. in the future, these methods can be adapted for some future need, but more likely than not, the future need can have its own funtion or class that suits the purpose of that future goal in a cleaner and more precise manner than trying to adapt old code to bend to a new idea. we dont want to tie ourselvs down to the limitations of our old code.\nprincipal 9: encapsulate functionality to ensure design consistancy. this minimises mistakes and saves design time. this one came about while id software were working on quake. an example of this principal in action were the torches on the walls. they could have made the designers place the torch model on the wall, then the fire model on top, then the torch sound effect. if they needed to move a torch to a new location, all three of these elements would need to be moved independly. it was far easier to create a torch entity that contained all the torch functionality and place the entity where needed.\nprincipal 10: try to code transparently. tell your lead and peers exactly how you are going to solve your current task and get feedback and advice. do not treat game programming like each coder is a black box. the project could go off the rails and cause delays. during id\u0026rsquo;s first 5.5 years, they shipped 28 games with less than 10 developers, as well as licencing their game engines to countless other games. this transparency enabled the team to know exactly what to expect from each other\u0026rsquo;s code and to solve problems together.\nprincipal 11: programming is a creative art form based in logic. every programmer is different and will code differently. it\u0026#39;s the output that matters. ive long held this belief. similar to the philosphy that restricts enable creativity, the rules and conventions of a programming framework provide guard rails and guides on how to solve problems in a creative and meaningful way. the creativity of programming comes from how the problem is solved, not just the solution.\n","title":"ID Software Prinicpals of Good Development"}]
}

